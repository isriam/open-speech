<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Open Speech</title>
<style>
:root {
  --bg: #1a1a2e;
  --bg2: #16213e;
  --bg3: #0f3460;
  --fg: #e0e0e0;
  --fg2: #a0a0b0;
  --accent: #e94560;
  --accent2: #0f3460;
  --green: #4ecca3;
  --red: #e94560;
  --border: #2a2a4a;
  --radius: 8px;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg); color: var(--fg); min-height: 100vh; }
.container { max-width: 900px; margin: 0 auto; padding: 20px; }
h1 { font-size: 1.5rem; margin-bottom: 4px; }
.subtitle { color: var(--fg2); font-size: 0.85rem; margin-bottom: 16px; }

/* Tabs */
.tabs { display: flex; gap: 0; border-bottom: 2px solid var(--border); margin-bottom: 20px; }
.tab { padding: 10px 24px; cursor: pointer; color: var(--fg2); border-bottom: 2px solid transparent; margin-bottom: -2px; transition: all 0.2s; font-size: 0.95rem; }
.tab:hover { color: var(--fg); }
.tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.panel { display: none; }
.panel.active { display: block; }

/* Form elements */
select, input[type=text], textarea {
  background: var(--bg2); color: var(--fg); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 8px 12px; width: 100%; font-size: 0.9rem;
}
select:focus, input:focus, textarea:focus { outline: none; border-color: var(--accent); }
textarea { resize: vertical; min-height: 100px; font-family: inherit; }
label { display: block; color: var(--fg2); font-size: 0.8rem; margin-bottom: 4px; margin-top: 12px; }
.row { display: flex; gap: 12px; align-items: end; }
.row > * { flex: 1; }

/* Buttons */
.btn {
  background: var(--accent); color: #fff; border: none; border-radius: var(--radius);
  padding: 10px 20px; cursor: pointer; font-size: 0.9rem; transition: opacity 0.2s;
}
.btn:hover { opacity: 0.85; }
.btn:disabled { opacity: 0.4; cursor: not-allowed; }
.btn-secondary { background: var(--bg3); }
.btn-sm { padding: 6px 14px; font-size: 0.8rem; }
.btn-danger { background: var(--red); }
.btn-success { background: var(--green); color: #1a1a2e; }

/* Drop zone */
.dropzone {
  border: 2px dashed var(--border); border-radius: var(--radius); padding: 30px;
  text-align: center; color: var(--fg2); cursor: pointer; transition: all 0.2s;
  margin-top: 12px;
}
.dropzone:hover, .dropzone.dragover { border-color: var(--accent); color: var(--fg); }
.dropzone input { display: none; }

/* Results */
.result-area {
  background: var(--bg2); border: 1px solid var(--border); border-radius: var(--radius);
  padding: 16px; margin-top: 16px; min-height: 60px; white-space: pre-wrap;
  font-family: 'SF Mono', 'Fira Code', monospace; font-size: 0.85rem; line-height: 1.5;
}
.result-area .partial { color: var(--fg2); }

/* WS status */
.ws-status { display: inline-flex; align-items: center; gap: 6px; font-size: 0.8rem; color: var(--fg2); }
.ws-dot { width: 8px; height: 8px; border-radius: 50%; background: var(--red); }
.ws-dot.connected { background: var(--green); }

/* Audio player */
audio { width: 100%; margin-top: 12px; }

/* Slider */
input[type=range] { width: 100%; accent-color: var(--accent); }

/* Models table */
.models-table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
.models-table th, .models-table td { padding: 8px 12px; text-align: left; border-bottom: 1px solid var(--border); }
.models-table th { color: var(--fg2); font-weight: 500; }
.badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; }
.badge-loaded { background: var(--green); color: #1a1a2e; }
.badge-unloaded { background: var(--border); color: var(--fg2); }

/* History */
.history { margin-top: 20px; }
.history h3 { font-size: 0.85rem; color: var(--fg2); margin-bottom: 8px; }
.history-item {
  background: var(--bg2); border: 1px solid var(--border); border-radius: var(--radius);
  padding: 10px; margin-bottom: 8px; font-size: 0.8rem; cursor: pointer;
}
.history-item:hover { border-color: var(--accent); }
.history-item .meta { color: var(--fg2); font-size: 0.75rem; }

/* Mic button */
.mic-btn { width: 48px; height: 48px; border-radius: 50%; border: none; cursor: pointer; font-size: 1.2rem; transition: all 0.2s; }
.mic-btn.recording { background: var(--red); animation: pulse 1.5s infinite; }
@keyframes pulse { 0%,100% { box-shadow: 0 0 0 0 rgba(233,69,96,0.4); } 50% { box-shadow: 0 0 0 12px rgba(233,69,96,0); } }

@media (max-width: 600px) {
  .row { flex-direction: column; }
  .tab { padding: 10px 14px; font-size: 0.85rem; }
}
</style>
</head>
<body>
<div class="container">
  <h1>üé§ Open Speech</h1>
  <p class="subtitle">OpenAI-compatible Speech Server</p>

  <div class="tabs">
    <div class="tab active" onclick="switchTab('transcribe')">Transcribe</div>
    <div class="tab" onclick="switchTab('speak')">Speak</div>
    <div class="tab" onclick="switchTab('models')">Models</div>
  </div>

  <!-- TRANSCRIBE TAB -->
  <div id="transcribe" class="panel active">
    <div class="row">
      <div>
        <label>STT Model</label>
        <select id="stt-model"></select>
      </div>
      <div>
        <label>Output Format</label>
        <select id="stt-format">
          <option value="text">Text</option>
          <option value="json" selected>JSON</option>
          <option value="srt">SRT</option>
          <option value="vtt">VTT</option>
        </select>
      </div>
    </div>

    <div class="dropzone" id="stt-dropzone">
      <input type="file" id="stt-file" accept=".wav,.mp3,.ogg,.flac,.m4a,.webm">
      üìÅ Drop audio file here or click to browse<br>
      <small>wav, mp3, ogg, flac, m4a, webm</small>
    </div>

    <div style="margin-top:16px; display:flex; align-items:center; gap:16px;">
      <button class="btn mic-btn btn-secondary" id="mic-btn" onclick="toggleMic()" title="Live microphone">üéôÔ∏è</button>
      <span class="ws-status"><span class="ws-dot" id="ws-dot"></span> <span id="ws-label">Disconnected</span></span>
      <button class="btn btn-sm btn-secondary" id="stt-download" onclick="downloadTranscript()" style="margin-left:auto;" disabled>‚¨á Download</button>
    </div>

    <div class="result-area" id="stt-result">Transcription will appear here...</div>

    <div class="history" id="stt-history"><h3>Recent Transcriptions</h3></div>
  </div>

  <!-- SPEAK TAB -->
  <div id="speak" class="panel">
    <label>Text</label>
    <textarea id="tts-text" placeholder="Enter text to synthesize..."></textarea>
    <div class="dropzone" id="tts-dropzone" style="padding:16px; margin-top:8px;">
      <input type="file" id="tts-file" accept=".txt">
      üìÑ Drop .txt file to load text
    </div>

    <div class="row">
      <div>
        <label>Voice</label>
        <select id="tts-voice"></select>
      </div>
      <div>
        <label>Voice Blend</label>
        <input type="text" id="tts-blend" placeholder="e.g. af_bella(2)+af_sky(1)">
      </div>
    </div>

    <div class="row">
      <div>
        <label>Speed: <span id="speed-val">1.0</span>x</label>
        <input type="range" id="tts-speed" min="0.25" max="4.0" step="0.25" value="1.0" oninput="document.getElementById('speed-val').textContent=this.value">
      </div>
      <div>
        <label>Format</label>
        <select id="tts-format">
          <option value="mp3" selected>MP3</option>
          <option value="wav">WAV</option>
          <option value="opus">Opus</option>
          <option value="flac">FLAC</option>
        </select>
      </div>
    </div>

    <div style="margin-top:16px; display:flex; gap:12px; align-items:center;">
      <button class="btn" id="speak-btn" onclick="doSpeak()">üîä Speak</button>
      <label style="margin:0;"><input type="checkbox" id="tts-stream"> Stream</label>
    </div>

    <audio id="tts-audio" controls style="display:none;"></audio>
    <div style="margin-top:8px;"><a id="tts-download" href="#" download style="display:none; color:var(--accent); font-size:0.85rem;">‚¨á Download audio</a></div>

    <div class="history" id="tts-history"><h3>Recent Generations</h3></div>
  </div>

  <!-- MODELS TAB -->
  <div id="models" class="panel">
    <table class="models-table">
      <thead><tr><th>Name</th><th>Type</th><th>Backend</th><th>Status</th><th>Device</th><th>Action</th></tr></thead>
      <tbody id="models-body"></tbody>
    </table>
    <p style="margin-top:12px; color:var(--fg2); font-size:0.8rem;" id="models-refresh">Auto-refreshes every 5s</p>
  </div>
</div>

<script>
// Tab switching
function switchTab(name) {
  document.querySelectorAll('.tab').forEach((t,i) => {
    const panels = ['transcribe','speak','models'];
    t.classList.toggle('active', panels[i] === name);
  });
  document.querySelectorAll('.panel').forEach(p => p.classList.toggle('active', p.id === name));
  if (name === 'models') refreshModels();
}

// --- STT ---
let sttHistory = [];
let lastTranscript = '';
let lastTranscriptFormat = 'text';

async function loadSTTModels() {
  try {
    const r = await fetch('/v1/models');
    const data = await r.json();
    const sel = document.getElementById('stt-model');
    sel.innerHTML = '';
    data.data.forEach(m => {
      if (m.owned_by && m.owned_by.includes('tts')) return;
      const o = document.createElement('option');
      o.value = m.id; o.textContent = m.id;
      sel.appendChild(o);
    });
  } catch(e) { console.error('Failed to load models', e); }
}

// File upload
const sttDZ = document.getElementById('stt-dropzone');
const sttFile = document.getElementById('stt-file');
sttDZ.onclick = () => sttFile.click();
sttDZ.ondragover = e => { e.preventDefault(); sttDZ.classList.add('dragover'); };
sttDZ.ondragleave = () => sttDZ.classList.remove('dragover');
sttDZ.ondrop = e => { e.preventDefault(); sttDZ.classList.remove('dragover'); if(e.dataTransfer.files.length) transcribeFile(e.dataTransfer.files[0]); };
sttFile.onchange = () => { if(sttFile.files.length) transcribeFile(sttFile.files[0]); };

async function transcribeFile(file) {
  const res = document.getElementById('stt-result');
  res.textContent = 'Transcribing...';
  const fmt = document.getElementById('stt-format').value;
  const model = document.getElementById('stt-model').value;
  const fd = new FormData();
  fd.append('file', file);
  fd.append('model', model);
  fd.append('response_format', fmt === 'json' ? 'verbose_json' : fmt);
  try {
    const r = await fetch('/v1/audio/transcriptions', { method: 'POST', body: fd });
    const ct = r.headers.get('content-type') || '';
    if (ct.includes('json')) {
      const data = await r.json();
      lastTranscript = JSON.stringify(data, null, 2);
      lastTranscriptFormat = 'json';
      res.textContent = data.text || lastTranscript;
    } else {
      lastTranscript = await r.text();
      lastTranscriptFormat = fmt;
      res.textContent = lastTranscript;
    }
    document.getElementById('stt-download').disabled = false;
    addSTTHistory(file.name, res.textContent.substring(0, 80));
  } catch(e) {
    res.textContent = 'Error: ' + e.message;
  }
}

function downloadTranscript() {
  if (!lastTranscript) return;
  const ext = {text:'.txt', json:'.json', srt:'.srt', vtt:'.vtt'}[lastTranscriptFormat] || '.txt';
  const blob = new Blob([lastTranscript], {type:'text/plain'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'transcript' + ext;
  a.click();
}

function addSTTHistory(name, preview) {
  sttHistory.unshift({name, preview, time: new Date().toLocaleTimeString()});
  if (sttHistory.length > 5) sttHistory.pop();
  renderSTTHistory();
}

function renderSTTHistory() {
  const el = document.getElementById('stt-history');
  el.innerHTML = '<h3>Recent Transcriptions</h3>';
  sttHistory.forEach(h => {
    const d = document.createElement('div');
    d.className = 'history-item';
    d.innerHTML = `<div>${h.preview}...</div><div class="meta">${h.name} ‚Ä¢ ${h.time}</div>`;
    el.appendChild(d);
  });
}

// --- Live Mic ---
let mediaRecorder = null;
let wsConn = null;

function toggleMic() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    stopMic();
  } else {
    startMic();
  }
}

async function startMic() {
  const btn = document.getElementById('mic-btn');
  const res = document.getElementById('stt-result');
  try {
    const stream = await navigator.mediaDevices.getUserMedia({audio: {sampleRate: 16000, channelCount: 1}});
    const model = document.getElementById('stt-model').value;
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    wsConn = new WebSocket(`${proto}//${location.host}/v1/audio/stream?model=${encodeURIComponent(model)}&sample_rate=16000`);
    wsConn.onopen = () => {
      document.getElementById('ws-dot').classList.add('connected');
      document.getElementById('ws-label').textContent = 'Connected';
    };
    wsConn.onclose = () => {
      document.getElementById('ws-dot').classList.remove('connected');
      document.getElementById('ws-label').textContent = 'Disconnected';
    };

    let fullText = '';
    wsConn.onmessage = e => {
      const msg = JSON.parse(e.data);
      if (msg.type === 'transcript') {
        if (msg.speech_final) {
          fullText = msg.text + ' ';
          res.innerHTML = fullText;
        } else if (msg.is_final) {
          fullText = msg.text + ' ';
          res.innerHTML = fullText;
        } else {
          res.innerHTML = fullText + '<span class="partial">' + msg.text.substring(fullText.trim().length) + '</span>';
        }
        lastTranscript = fullText + (msg.text || '');
        lastTranscriptFormat = 'text';
        document.getElementById('stt-download').disabled = false;
      }
    };

    // Use AudioWorklet or ScriptProcessor to get PCM
    const audioCtx = new AudioContext({sampleRate: 16000});
    const source = audioCtx.createMediaStreamSource(stream);
    const processor = audioCtx.createScriptProcessor(4096, 1, 1);
    processor.onaudioprocess = e => {
      if (wsConn && wsConn.readyState === WebSocket.OPEN) {
        const f32 = e.inputBuffer.getChannelData(0);
        const i16 = new Int16Array(f32.length);
        for (let i = 0; i < f32.length; i++) i16[i] = Math.max(-32768, Math.min(32767, f32[i] * 32768));
        wsConn.send(i16.buffer);
      }
    };
    source.connect(processor);
    processor.connect(audioCtx.destination);

    mediaRecorder = {state:'recording', stop: () => {
      processor.disconnect(); source.disconnect(); audioCtx.close();
      stream.getTracks().forEach(t => t.stop());
      if (wsConn && wsConn.readyState === WebSocket.OPEN) {
        wsConn.send(JSON.stringify({type:'stop'}));
        wsConn.close();
      }
      mediaRecorder = null;
    }};

    btn.classList.add('recording');
    btn.textContent = '‚èπ';
    res.textContent = 'Listening...';
  } catch(e) {
    res.textContent = 'Mic error: ' + e.message;
  }
}

function stopMic() {
  if (mediaRecorder) mediaRecorder.stop();
  const btn = document.getElementById('mic-btn');
  btn.classList.remove('recording');
  btn.textContent = 'üéôÔ∏è';
  addSTTHistory('Microphone', document.getElementById('stt-result').textContent.substring(0, 80));
}

// --- TTS ---
let ttsHistory = [];

async function loadVoices() {
  try {
    const r = await fetch('/v1/audio/voices');
    const data = await r.json();
    const sel = document.getElementById('tts-voice');
    sel.innerHTML = '';
    (data.voices || []).forEach(v => {
      const o = document.createElement('option');
      o.value = v.id;
      o.textContent = `${v.name} (${v.id}) ‚Äî ${v.language}`;
      if (v.id === 'af_heart') o.selected = true;
      sel.appendChild(o);
    });
  } catch(e) { console.error('Failed to load voices', e); }
}

// TTS file upload
const ttsDZ = document.getElementById('tts-dropzone');
const ttsFileInput = document.getElementById('tts-file');
ttsDZ.onclick = () => ttsFileInput.click();
ttsDZ.ondragover = e => { e.preventDefault(); ttsDZ.classList.add('dragover'); };
ttsDZ.ondragleave = () => ttsDZ.classList.remove('dragover');
ttsDZ.ondrop = e => { e.preventDefault(); ttsDZ.classList.remove('dragover'); if(e.dataTransfer.files.length) loadTextFile(e.dataTransfer.files[0]); };
ttsFileInput.onchange = () => { if(ttsFileInput.files.length) loadTextFile(ttsFileInput.files[0]); };

function loadTextFile(file) {
  const reader = new FileReader();
  reader.onload = e => { document.getElementById('tts-text').value = e.target.result; };
  reader.readAsText(file);
}

async function doSpeak() {
  const btn = document.getElementById('speak-btn');
  btn.disabled = true;
  btn.textContent = '‚è≥ Generating...';
  const text = document.getElementById('tts-text').value;
  const blend = document.getElementById('tts-blend').value;
  const voice = blend || document.getElementById('tts-voice').value;
  const speed = parseFloat(document.getElementById('tts-speed').value);
  const fmt = document.getElementById('tts-format').value;
  const doStream = document.getElementById('tts-stream').checked;

  try {
    const url = '/v1/audio/speech' + (doStream ? '?stream=true' : '');
    const r = await fetch(url, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({input: text, voice, speed, response_format: fmt}),
    });
    const blob = await r.blob();
    const audioUrl = URL.createObjectURL(blob);
    const audio = document.getElementById('tts-audio');
    audio.src = audioUrl;
    audio.style.display = 'block';
    audio.play();
    const dl = document.getElementById('tts-download');
    dl.href = audioUrl;
    dl.download = 'speech.' + fmt;
    dl.style.display = 'inline';
    addTTSHistory(text.substring(0, 60), voice);
  } catch(e) {
    alert('TTS error: ' + e.message);
  } finally {
    btn.disabled = false;
    btn.textContent = 'üîä Speak';
  }
}

function addTTSHistory(preview, voice) {
  ttsHistory.unshift({preview, voice, time: new Date().toLocaleTimeString()});
  if (ttsHistory.length > 5) ttsHistory.pop();
  renderTTSHistory();
}

function renderTTSHistory() {
  const el = document.getElementById('tts-history');
  el.innerHTML = '<h3>Recent Generations</h3>';
  ttsHistory.forEach(h => {
    const d = document.createElement('div');
    d.className = 'history-item';
    d.innerHTML = `<div>${h.preview}...</div><div class="meta">${h.voice} ‚Ä¢ ${h.time}</div>`;
    d.onclick = () => { document.getElementById('tts-text').value = h.preview; };
    el.appendChild(d);
  });
}

// --- Models ---
let modelsInterval = null;

async function refreshModels() {
  try {
    const [sttR, ttsR] = await Promise.all([
      fetch('/v1/models').then(r => r.json()),
      fetch('/v1/audio/models').then(r => r.json()).catch(() => ({models:[]})),
    ]);
    const body = document.getElementById('models-body');
    body.innerHTML = '';

    // STT models
    (sttR.data || []).forEach(m => {
      if (m.owned_by && m.owned_by.includes('tts')) return;
      const tr = document.createElement('tr');
      const backend = (m.owned_by || '').replace('open-speech/', '') || 'unknown';
      tr.innerHTML = `<td>${m.id}</td><td>STT</td><td>${backend}</td>
        <td><span class="badge badge-loaded">loaded</span></td><td>‚Äî</td>
        <td><button class="btn btn-sm btn-danger" onclick="unloadModel('${m.id}','stt')">Unload</button></td>`;
      body.appendChild(tr);
    });

    // TTS models
    (ttsR.models || []).forEach(m => {
      const tr = document.createElement('tr');
      const loaded = m.status === 'loaded';
      tr.innerHTML = `<td>${m.model}</td><td>TTS</td><td>${m.backend || '‚Äî'}</td>
        <td><span class="badge ${loaded?'badge-loaded':'badge-unloaded'}">${m.status}</span></td>
        <td>${m.device || '‚Äî'}</td>
        <td>${loaded
          ? `<button class="btn btn-sm btn-danger" onclick="unloadModel('${m.model}','tts')">Unload</button>`
          : `<button class="btn btn-sm btn-success" onclick="loadModel('${m.model}','tts')">Load</button>`
        }</td>`;
      body.appendChild(tr);
    });
  } catch(e) { console.error('Failed to refresh models', e); }

  if (!modelsInterval) {
    modelsInterval = setInterval(refreshModels, 5000);
  }
}

async function loadModel(id, type) {
  if (type === 'tts') await fetch('/v1/audio/models/load', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({model:id})});
  else await fetch(`/api/ps/${id}`, {method:'POST'});
  refreshModels();
}

async function unloadModel(id, type) {
  if (type === 'tts') await fetch('/v1/audio/models/unload', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({model:id})});
  else await fetch(`/api/ps/${id}`, {method:'DELETE'});
  refreshModels();
}

// Init
loadSTTModels();
loadVoices();
</script>
</body>
</html>
